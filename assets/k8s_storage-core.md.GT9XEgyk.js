import{_ as e,o,c as t,R as a}from"./chunks/framework.PTn1Zvbw.js";const p=JSON.parse('{"title":"Kubenetes-应用配置管理应用存储和持久化数据卷-核心知识","description":"","frontmatter":{"outline":"deep"},"headers":[],"relativePath":"k8s/storage-core.md","filePath":"k8s/storage-core.md"}'),d={name:"k8s/storage-core.md"},r=a('<h1 id="kubenetes-应用配置管理应用存储和持久化数据卷-核心知识" tabindex="-1">Kubenetes-应用配置管理应用存储和持久化数据卷-核心知识 <a class="header-anchor" href="#kubenetes-应用配置管理应用存储和持久化数据卷-核心知识" aria-label="Permalink to &quot;Kubenetes-应用配置管理应用存储和持久化数据卷-核心知识&quot;">​</a></h1><h2 id="卷介绍" tabindex="-1">卷介绍 <a class="header-anchor" href="#卷介绍" aria-label="Permalink to &quot;卷介绍&quot;">​</a></h2><h3 id="pod-卷" tabindex="-1">Pod 卷 <a class="header-anchor" href="#pod-卷" aria-label="Permalink to &quot;Pod 卷&quot;">​</a></h3><ol><li>如果一个<code>Pod</code>中某一个容器<code>异常退出</code>，被<code>kubelet</code>拉起如何保证之前产生的重要数据不丢?</li><li>同一个<code>Pod</code>的多个容器如何<code>共享数据</code>?</li></ol><h4 id="卷类型" tabindex="-1">卷类型 <a class="header-anchor" href="#卷类型" aria-label="Permalink to &quot;卷类型&quot;">​</a></h4><table><thead><tr><th>方式</th><th>类型</th></tr></thead><tbody><tr><td>本地存储</td><td><code>emptydir</code>、<code>hostpath</code></td></tr><tr><td>网络存储</td><td>in-tree：<code>nfs</code>、<code>awsElasticBlockStore</code>、<code>gcePersistentDisk</code><br>out-of-tree：<code>flexvolume</code>、<code>csi等网络存储volume plugins</code></td></tr><tr><td>Projected Volume</td><td><code>secret</code>、<code>configmap</code>、<code>downwardAPI</code>、<code>serviceAccountToken</code></td></tr><tr><td>PV 与 PVC 体系</td><td><a href="#持久卷"><code>PersistentVolume</code></a>、<a href="#持久卷申领"><code>persistentVolumeClaim</code></a></td></tr></tbody></table><h4 id="持久卷" tabindex="-1">持久卷 <a class="header-anchor" href="#持久卷" aria-label="Permalink to &quot;持久卷&quot;">​</a></h4><p>Persistent Volumes（PV）</p><p><strong>Pod 中声明的 volume（卷）的生命周期与 Pod 相同，以下常见场景：</strong></p><ol><li>Pod 销毁重建（如 Deployment 管理的 Pod 镜像升级）</li><li>宿主机故障迁移（如 StatefulSet 管理的 Pod 带远程 volume 迁移）</li><li>多 Pod 共享同一个数据 volume</li><li>数据 volume snapshot（卷快照）, resize 等功能的扩展实现</li></ol><ul><li>不足之处:</li></ul><p>使用 Pod Volumes 无法准确表达数据 volume 复用/共享语义，新功能扩展很难实现。</p><ul><li>优化:</li></ul><p>如果能将存储与计算分离，使用不同的组件(<code>Controllers</code>)管理存储与计算资源，解耦 Pod 与 Volume 的生命周期关联，可以很好的解决这些场景下的问题。</p><h4 id="持久卷申领" tabindex="-1">持久卷申领 <a class="header-anchor" href="#持久卷申领" aria-label="Permalink to &quot;持久卷申领&quot;">​</a></h4><p>PersistentVolumeClaim（PVC）</p><p><strong>有了 PV（持久卷，PersistentVolume），为什么又设计了 PVC ？</strong></p><ol><li><strong>职责分离</strong>，PVC 中只用声明自己需要的存储 size、access mode（单 node 独占还是多 node 共享？只读还是读写访问？）等业务真正关心的存储需求（不用关心存储实现细节），PV 和其对应的后端存储信息则由交给 cluster admin 统一运维和管控，安全访问策略更容易控制。</li><li><strong>PVC 简化了 User 对存储的需求，PV 才是存储的实际信息的承载体</strong>，通过 kube-controller-manager 中的 PersisentVolumeController 将 PVC 与合适的 PV bound 到一起，从而满足 User 对存储的实际需求。</li><li>PVC 像是面向对象编程中抽象出来的接口，PV 是接口对应的实现。</li></ol><h2 id="用例解读" tabindex="-1">用例解读 <a class="header-anchor" href="#用例解读" aria-label="Permalink to &quot;用例解读&quot;">​</a></h2><h2 id="操作演示" tabindex="-1">操作演示 <a class="header-anchor" href="#操作演示" aria-label="Permalink to &quot;操作演示&quot;">​</a></h2><h2 id="架构设计" tabindex="-1">架构设计 <a class="header-anchor" href="#架构设计" aria-label="Permalink to &quot;架构设计&quot;">​</a></h2>',21),l=[r];function s(c,i,n,h,u,P){return o(),t("div",null,l)}const b=e(d,[["render",s]]);export{p as __pageData,b as default};
